<!DOCTYPE html>
<html>
<body>

	<canvas id="content" width="1400" height="900" style="border: 1px solid gray; margin: 10px; float: left;"></canvas>

<script>
/*       CONSTANTS      */
var SCALE = 4;
var LINE_ERROR = 1/4 * SCALE;
var POINT_ERROR = 1/2 * SCALE;

/*        "CLASSES"            */
function Point(x, y) { 
	return { 
		x: x,
		y: y,
		clone: function() { return Point(this.x, this.y); },
		scale: function(scale) {
			return Point(this.x / scale, this.y / scale);
		},
		moveBy: function(mx, my) {
			return Point(this.x + mx, this.y + my);
		},
		distanceTo: function(o) {
			var dx = Math.abs(this.x - o.x);
			var dy = Math.abs(this.y - o.y);
			return Math.sqrt(dx * dx + dy * dy);
		},
		equals: function(o, tolerance) {
			if (arguments.length == 1) return this.x == o.x && this.y == o.y;
			return Math.abs(this.x - o.x) < tolerance && Math.abs(this.y - o.y) < tolerance;
		},
		moveTo: function() {
			if (arguments.length < 1) return;
			if (arguments.length == 1) {
				this.x = arguments[0].x;
				this.y = arguments[0].y;
				return;
			}
			this.x = arguments[0];
			this.y = arguments[1];
			return;
		},
	};
}

function Rect() { 
	var ret = {};
	if (arguments.length == 1) {
		if (Array.isArray(arguments[0])) { //from points list
			var a = arguments[0];
			if (a.length < 1) return;
			ret.l = a[0].x;
			ret.r = a[0].x;
			ret.t = a[0].y;
			ret.b = a[0].y;
			for (i = 1, l = a.length; i < l; ++i) {
				if (a[i].x < ret.l) ret.l = a[i].x;
				if (a[i].x > ret.r) ret.r = a[i].x;
				if (a[i].y < ret.t) ret.t = a[i].y;
				if (a[i].y > ret.b) ret.b = a[i].y;
			}
		} else { //copy
			var p = arguments[0];
			ret.l = p.l;
			ret.r = p.r;
			ret.t = p.t;
			ret.b = p.b;
		}
	} else if (arguments.length == 2) { //from 2 points
		var p1 = arguments[0];
		var p2 = arguments[1];
		if (p1.x > p2.x) {
			ret.l = p2.x;
			ret.r = p1.x;
		} else {
			ret.l = p1.x;
			ret.r = p2.x;
		}
		
		if (p1.y > p2.y) {
			ret.t = p2.y;
			ret.b = p1.y;
		} else {
			ret.t = p1.y;
			ret.b = p2.y;
		}
	} else if (arguments.length == 4) { //from direct values
		ret.l = arguments[0];
		ret.r = arguments[1];
		ret.t = arguments[2];
		ret.b = arguments[3];
	} else return;
	ret.clone = function() { return Rect(this); };
	ret.contains = function(point) {
		return point.x >= this.l && point.x <= this.r && point.y >= this.t && point.y <= this.b;
	};
	ret.enlarge = function() {
		if(arguments.length == 0) return Rect(this);
		if(arguments.length == 1) {
			var add = arguments[0];
			return Rect(
				this.l - add,
				this.r + add,
				this.t - add,
				this.b + add
			);
		}
		if(arguments.length == 2) {
			var h = arguments[0];
			var w = arguments[1];
			return Rect(
				this.l - w,
				this.r + w,
				this.t - h,
				this.b + h
			);
		}
		if(arguments.length == 4) {
			return Rect(
				this.l - arguments[0],
				this.r + arguments[1],
				this.t - arguments[2],
				this.b + arguments[3]
			);
		}
		return Rect(this);
	};
	ret.width = function() {
		return this.r - this.l;
	};
	ret.height = function() {
		return this.b - this.t;
	};
	ret.equals = function(o) {
		return this.l == o.l && this.r == o.r && this.t == o.t && this.b == o.b;
	};
	ret.center = function() {
		return Point((this.l + this.r) / 2, (this.t + this.b) / 2);
	};
	return ret;
}

function Polygon() {
	var ret = {};
	ret.path = arguments[0];
	ret.clone = function() { return Polygon(arrayCopy(this.path)); };
	ret.center = function() { return Rect(this.path).center(); };
	ret.getIndexOnEdge = function(point) {
		if (this.path.length < 1) return null;
		if (this.path.length == 1) {
			if (this.path[0].equals(point, POINT_ERROR)) return 0;
			return null;
		}
		
		for (var i = 0, l = this.path.length - 1; i < l; ++i) {
			if (this.path[i].equals(point, POINT_ERROR)) return i;
			if (this.path[i + 1].equals(point, POINT_ERROR)) return i + 1;
			if (isPointOnLine(this.path[i], this.path[i + 1], point)) return i + 0.5;
		}
		if (this.path.length > 2 && isPointOnLine(this.path[this.path.length - 1], this.path[0], point)) return this.path.length - 0.5;
		
		return null;
	};
	ret.isPointOnEdge = function(point) { return getIndexOnEdge(point) != null; };
	ret.insert = function(index, point) {
		this.path = arrayInsert(this.path, index, point);
	};
	ret.get = function(index) { return this.path[index]; };
	return ret;
}

/*      extensions     */
function appendEventExtensions(element, event) {
	event.relativeX = event.pageX - element.offsetLeft;
	event.relativeY = event.pageY - element.offsetTop;
	event.point = Point(event.x, event.y);
	event.pagePoint = Point(event.pageX, event.pageY);
	event.relativePoint = Point(event.relativeX, event.relativeY);
}

/*          FUNCTIONS          */
function isPointOnLine(l1, l2, point) {
	if (!Rect(l1, l2).enlarge(LINE_ERROR).contains(point)) return false;
	
	var l = l2.moveBy(-l1.x, -l1.y);
	if (l.x == 0) { //vertical
		return Math.abs(l1.x - point.x) < LINE_ERROR;
	} else if (l.y == 0) { //horizontal
		return Math.abs(l1.y - point.y) < LINE_ERROR;
	} else {
		var relativePoint = point.moveBy(-l1.x, -l1.y);
		
		var lSlope = l.y / l.x;
		var pSlope = -1 / lSlope;
		
		var pc = relativePoint.y - (pSlope * relativePoint.x);
		var cX = pc / (lSlope - pSlope);
		var cY = cX * lSlope;
		var crossPoint = Point(cX, cY);
		
		return crossPoint.distanceTo(relativePoint) < LINE_ERROR;
	}
}

function arrayInsert(array, index, item) {
	if (index >= array.length) {
		return [ ...array, item ]
	} else {
		var ret = [];
		for(i = 0, l = array.length; i < l; i++) {
			if (index == i) ret.push(item);
			ret.push(array[i]);
		}
		return ret;
	}
}

function arrayCopy(array) {
	var ret = [];
	for (i = 0, l = array.length; i < l; ++i) {
		ret.push(array[i].clone());
	}
	return ret;
}

/*            GLOBALS           */
var c = document.getElementById("content");
var d = c.getContext("2d");

/* 
 - add posibility to add more independant objects
	- merging objects when intersect ?
 - simplify object when point on line within LINE_ERROR
*/
var path = Polygon([
	Point(78.25, 96.5),
	Point(101.5, 107.5),
	Point(123, 100),
	Point(138.25, 72.25),
	Point(111, 50),
	Point(80, 70),
]);

var userPath = path.clone();


d.scale(SCALE, SCALE);

function redraw() { draw(userPath); }

function draw(polygon) {
	var path = polygon.path;
	d.clearRect(0, 0, c.width, c.height);
	d.beginPath();
	d.lineWidth = 1;
	d.strokeStyle = "#000000";
	d.fillStyle = "#000000";
	if (path.length > 0) {
		d.moveTo(path[0].x, path[0].y);
		for(l = path.length, i = 1; i < l; ++i) {
			d.lineTo(path[i].x, path[i].y);
		}
	}
	d.closePath();
	d.stroke();
}

var trackMouse = null

c.addEventListener("mousedown", function(event) {
	appendEventExtensions(c, event);
	var p = event.relativePoint.scale(SCALE);
//	console.log("<- down x:"+p.x+", y:"+p.y);
	
	var w = userPath.getIndexOnEdge(p)
	var i = parseInt(w);
	if (i == w) trackMouse = userPath.get(i);
	else {
		userPath.insert(i + 1, p);
		trackMouse = p;
	}
}, false);

c.addEventListener("mousemove", function(event) {
	appendEventExtensions(c, event);
	if (trackMouse === null) return;
	var p = event.relativePoint.scale(SCALE);
//	console.log("-- move x:"+p.x+", y:"+p.y)
	trackMouse.moveTo(p);
	redraw();
}, false);

c.addEventListener("mouseup", function(event) {
	appendEventExtensions(c, event);
	if (trackMouse === null) return;
	trackMouse = null;
	var p = event.relativePoint.scale(SCALE);
//	console.log("-> up   x:"+p.x+", y:"+p.y)
	path = userPath.clone();
	redraw();
}, false);

c.addEventListener("mouseout", function(event) {
	appendEventExtensions(c, event);
	if (trackMouse === null) return;
	trackMouse = null;
	var p = event.relativePoint.scale(SCALE);
//	console.log("-> out  x:"+p.x+", y:"+p.y)
	userPath = path.clone();
	redraw();
}, false);

redraw()

</script>
</body>
</html>
