<!DOCTYPE html>
<html>
<body>
	<div style="display: block; float: left;">
		<canvas id="content" width="1200" height="900" style="border: 1px solid gray; margin: 10px; float: left;"></canvas>
		<div style="float: left;">
			<div>
				<ul>
					<li>You can grab vertex to move it.</li>
					<li>You can grab side to create new vertx.</li>
					<li>Last action will cancel if you move out of the box.</li>
					<li>Clicking on vertex will remove it (max down to triangle).</li>
				</ul>
			</div>
			<div id="alg_cont" style="clear: left; border: none; margin: 10px;"></div>
		</div>
	</div>
<script>
/*       CONSTANTS      */
var SCALE = 4;
var LINE_ERROR = 1/4 * SCALE;
var POINT_ERROR = 1/2 * SCALE;

/*        "CLASSES"            */
function Point(x, y) { 
	return { 
		x: x,
		y: y,
		clone: function() { return Point(this.x, this.y); },
		distanceTo: function(o) {
			var dx = Math.abs(this.x - o.x);
			var dy = Math.abs(this.y - o.y);
			return Math.sqrt(dx * dx + dy * dy);
		},
		draw: function(d2d, options) {
			d2d.drawCircle(Circle(this, 0.5), options);
		},
		equals: function(o, tolerance) {
			if (arguments.length == 1) return this.x == o.x && this.y == o.y;
			return Math.abs(this.x - o.x) < tolerance && Math.abs(this.y - o.y) < tolerance;
		},
		moveBy: function(mx, my) {
			return Point(this.x + mx, this.y + my);
		},
		moveTo: function() {
			if (arguments.length < 1) return;
			if (arguments.length == 1) {
				this.x = arguments[0].x;
				this.y = arguments[0].y;
				return;
			}
			this.x = arguments[0];
			this.y = arguments[1];
			return;
		},
		scale: function(scale) {
			return Point(this.x / scale, this.y / scale);
		},
	};
}

function Rect() { 
	var ret = {};
	if (arguments.length == 1) {
		if (Array.isArray(arguments[0])) { //from points list
			var a = arguments[0];
			if (a.length < 1) return;
			ret.l = a[0].x;
			ret.r = a[0].x;
			ret.t = a[0].y;
			ret.b = a[0].y;
			for (i = 1, l = a.length; i < l; ++i) {
				if (a[i].x < ret.l) ret.l = a[i].x;
				if (a[i].x > ret.r) ret.r = a[i].x;
				if (a[i].y < ret.t) ret.t = a[i].y;
				if (a[i].y > ret.b) ret.b = a[i].y;
			}
		} else { //copy
			var p = arguments[0];
			ret.l = p.l;
			ret.r = p.r;
			ret.t = p.t;
			ret.b = p.b;
		}
	} else if (arguments.length == 2) { //from 2 points
		var p1 = arguments[0];
		var p2 = arguments[1];
		if (p1.x > p2.x) {
			ret.l = p2.x;
			ret.r = p1.x;
		} else {
			ret.l = p1.x;
			ret.r = p2.x;
		}
		
		if (p1.y > p2.y) {
			ret.t = p2.y;
			ret.b = p1.y;
		} else {
			ret.t = p1.y;
			ret.b = p2.y;
		}
	} else if (arguments.length == 4) { //from direct values
		ret.l = arguments[0];
		ret.r = arguments[1];
		ret.t = arguments[2];
		ret.b = arguments[3];
	} else return;
	ret.clone = function() { return Rect(this); };
	ret.center = function() {
		return Point((this.l + this.r) / 2, (this.t + this.b) / 2);
	};
	ret.contains = function(point) {
		return point.x >= this.l && point.x <= this.r && point.y >= this.t && point.y <= this.b;
	};
	ret.draw = function(d2d, options) {
		d2d.drawRect(this, options);
	};
	ret.enlarge = function() {
		if(arguments.length == 0) return Rect(this);
		if(arguments.length == 1) {
			var add = arguments[0];
			return Rect(
				this.l - add,
				this.r + add,
				this.t - add,
				this.b + add
			);
		}
		if(arguments.length == 2) {
			var h = arguments[0];
			var w = arguments[1];
			return Rect(
				this.l - w,
				this.r + w,
				this.t - h,
				this.b + h
			);
		}
		if(arguments.length == 4) {
			return Rect(
				this.l - arguments[0],
				this.r + arguments[1],
				this.t - arguments[2],
				this.b + arguments[3]
			);
		}
		return Rect(this);
	};
	ret.equals = function(o) {
		return this.l == o.l && this.r == o.r && this.t == o.t && this.b == o.b;
	};
	ret.height = function() {
		return this.b - this.t;
	};
	ret.width = function() {
		return this.r - this.l;
	};
	return ret;
}

function Polygon(points) {
	var ret = {};
	ret.path = points;
	ret.clone = function() { return Polygon(arrayClone(this.path)); };
	ret.bounds = function() { return Rect(this.path); };
	ret.center = function() { return Rect(this.path).center(); };
	ret.draw = function(d2d, options) {
		d2d.drawPolygon(this, options);
	};
	ret.length = function() { return this.path.length; };
	ret.get = function(index) { return this.path[index]; };
	ret.getIndexOnEdge = function(point) {
		if (this.path.length < 1) return null;
		if (this.path.length == 1) {
			if (this.path[0].equals(point, POINT_ERROR)) return 0;
			return null;
		}
		
		for (var i = 0, l = this.path.length - 1; i < l; ++i) {
			if (this.path[i].equals(point, POINT_ERROR)) return i;
			if (this.path[i + 1].equals(point, POINT_ERROR)) return i + 1;
			if (isPointOnLine(this.path[i], this.path[i + 1], point)) return i + 0.5;
		}
		if (this.path.length > 2 && isPointOnLine(this.path[this.path.length - 1], this.path[0], point)) return this.path.length - 0.5;
		
		return null;
	};
	ret.isPointOnEdge = function(point) { return getIndexOnEdge(point) != null; };
	ret.insert = function(index, point) {
		this.path.splice(index, 0, point);
	};
	ret.remove = function(index) {
		this.path.splice(index, 1);
	};
	return ret;
}

function Circle(point, radius) {
	return {
		center: point,
		radius: radius,
		clone: function() { return Circle(this.center, this.radius); },
		draw: function(d2d, options) {
			d2d.drawCircle(this, options);
		},
	};
}

/*      extensions     */
function appendMouseEventExtensions(event) {
	event.relativeX = event.pageX - event.target.offsetLeft;
	event.relativeY = event.pageY - event.target.offsetTop;
	event.point = Point(event.x, event.y);
	event.pagePoint = Point(event.pageX, event.pageY);
	event.relativePoint = Point(event.relativeX, event.relativeY);
}

function appendDrawingExtensions(draw2d) {
	draw2d.applyStyle = function(options) {
		this.lineWidth = options.lineWidth || 1;
		this.strokeStyle = options.strokeStyle || "#000000";
		this.fillStyle = options.fillStyle || "#000000";
	};
	draw2d.drawPolygon = function(polygon, options = {}) {
		this.applyStyle(options);
		this.beginPath();
		
		var path = polygon.path;
		if (path.length > 0) {
			this.moveTo(path[0].x, path[0].y);
			for(l = path.length, i = 1; i < l; ++i) {
				this.lineTo(path[i].x, path[i].y);
			}
		}
		this.closePath();
		
		if (options.stroke != false) {
			this.stroke();
		}
		if (options.fill == true) {
			this.fill();
		}
	};
	draw2d.drawCircle = function(circle, options = {}) {
		this.applyStyle(options);
		this.beginPath();
		
		this.arc(circle.center.x, circle.center.y, circle.radius, 0, 2 * Math.PI);
		
		if (options.stroke != false) {
			this.stroke();
		}
		if (options.fill == true) {
			this.fill();
		}
	};
	draw2d.drawRect = function(rect, options = {}) {
		this.applyStyle(options);
		this.beginPath;
		
		if (options.stroke != false) {
			this.strokeRect(rect.l, rect.t, rect.width(), rect.height());
		}
		if (options.fill == true) {
			this.fillRect(rect.l, rect.t, rect.width(), rect.height());
		}
	};
}

/*          FUNCTIONS          */
function isPointOnLine(l1, l2, point) {
	if (!Rect(l1, l2).enlarge(LINE_ERROR).contains(point)) return false;
	
	var l = l2.moveBy(-l1.x, -l1.y);
	if (l.x == 0) { //vertical
		return Math.abs(l1.x - point.x) < LINE_ERROR;
	} else if (l.y == 0) { //horizontal
		return Math.abs(l1.y - point.y) < LINE_ERROR;
	} else {
		var relativePoint = point.moveBy(-l1.x, -l1.y);
		
		var lSlope = l.y / l.x;
		var pSlope = -1 / lSlope;
		
		var pc = relativePoint.y - (pSlope * relativePoint.x);
		var cX = pc / (lSlope - pSlope);
		var cY = cX * lSlope;
		var crossPoint = Point(cX, cY);
		
		return crossPoint.distanceTo(relativePoint) < LINE_ERROR;
	}
}

function arrayClone(array) {
	var ret = [];
	for (i = 0, l = array.length; i < l; ++i) {
		ret.push(array[i].clone());
	}
	return ret;
}

/*            GLOBALS           */
var c = document.getElementById("content");
var d = c.getContext("2d");
appendDrawingExtensions(d);
d.scale(SCALE, SCALE);

/* 
 - add posibility to add more independant objects
	- merging objects when intersect ?
 - simplify object when point on line within LINE_ERROR
*/
var path = Polygon([
	Point(78.25, 96.5),
	Point(101.5, 107.5),
	Point(123, 100),
	Point(138.25, 72.25),
	Point(111, 50),
	Point(80, 70),
]);

var userPath = path.clone();

var algorithms = [
	{
		desc: "Show polygon center",
		show: false,
		drawOptions: {},
		fun: function(poly) {
			return [
				poly.center(),
			];
		},
	},
	{
		desc: "Show polygon bounds",
		show: false,
		drawOptions: {
			lineWidth: 0.1,
			strokeStyle: "#333",
		},
		fun: function(poly) {
			return [
				poly.bounds(),
			];
		},
	},
	{
		desc: "Show vertices",
		show: true,
		drawOptions: {
			lineWidth: 1.5,
		},
		fun: function(poly) {
			return poly.path;
		},
	},
	{
		desc: "1: Single circle from center with radius of distance to furthest vertex",
		show: false,
		drawOptions: {
			lineWidth: 0.5,
			strokeStyle: "#80000040",
			fillStyle: "#80000008",
			fill: true,
		},
		fun: function(poly) {
			var center = poly.center();
			var radius = 0;
			
			for (i = 0; i < poly.length(); ++i) {
				var distance = center.distanceTo(poly.get(i));
				if (distance > radius) radius = distance;
			}
			
			return [
				Circle(center, radius),
			];
		},
	},
	{
		desc: "2: Circle from each vertex, radius to furthest neighbour",
		show: false,
		drawOptions: {
			lineWidth: 0.3,
			strokeStyle: "#00800040",
			fillStyle: "#00800008",
			fill: true,
		},
		fun: function(poly) {
			var ret = [];
			function getFurthest(th, n, p) {
				return Math.max(th.distanceTo(n), th.distanceTo(p));
			}
			ret.push(Circle(poly.get(0), getFurthest(poly.get(0), poly.get(1), poly.get(poly.length() - 1)))); 
			for (i = 1; i < poly.length() - 1; ++i) {
				ret.push(Circle(poly.get(i), getFurthest(poly.get(i), poly.get(i + 1), poly.get(i - 1))))
			}
			ret.push(Circle(poly.get(poly.length() - 1), getFurthest(poly.get(poly.length() - 1), poly.get(0), poly.get(poly.length() - 2))));
			return ret;
		},
	},
	{
		desc: "3: Circle from center or each side + margin",
		show: false,
		drawOptions: {
			lineWidth: 0.3,
			strokeStyle: "#00008040",
			fillStyle: "#00008008",
			fill: true,
		},
		fun: function(poly) {
			var ret = [];
			for (i = 0, l = poly.length() - 1; i < l; ++i) {
				var r = Rect(poly.get(i), poly.get(i + 1));
				var c = r.center();
				ret.push(Circle(c, c.distanceTo(poly.get(i))*1.2));
			}
			{
				var r = Rect(poly.get(poly.length() - 1), poly.get(0));
				var c = r.center();
				ret.push(Circle(c, c.distanceTo(poly.get(i))*1.2));
			}
			
			return ret;
		},
	},
	{
		desc: "4: Circle from each vertex with radius to center of polygon",
		show: false,
		drawOptions: {
			lineWidth: 0.3,
			strokeStyle: "#80008040",
			fillStyle: "#80008008",
			fill: true,
		},
		fun: function(poly) {
			var ret = [];
			var center = poly.center();
			for (i = 0; i < poly.length(); ++i) {
				var p = poly.get(i);
				ret.push(Circle(p, p.distanceTo(center)));
			}
			return ret;
		},
	},
];


function redraw() { 
	d.clearRect(0, 0, c.width, c.height);
	d.drawPolygon(userPath);
	for (a = 0; a < algorithms.length; ++a) {
		var alg = algorithms[a]
		if (alg.show) {
			var shapes = alg.fun(userPath);
			for(i = 0; i < shapes.length; ++i) {
				shapes[i].draw(d, alg.drawOptions);
			}
		}
	}
}

/*           event handling           */
(function() {
	var mousePoint = null;
	var mousePointIndex = null;
	var mouseMoved = false;

	c.addEventListener("mousedown", function(event) {
		appendMouseEventExtensions(event);
		var p = event.relativePoint.scale(SCALE);
	//	console.log("<- down x:"+p.x+", y:"+p.y);
		
		var w = userPath.getIndexOnEdge(p)
		if (w == null) return;
		var i = parseInt(w);
		if (i == w) {
			mousePoint = userPath.get(i);
			mousePointIndex = i;
		} else {
			userPath.insert(i + 1, p);
			mousePoint = p;
			mousePointIndex = i + 1;
		}
		mouseMoved = false;
	});

	c.addEventListener("mousemove", function(event) {
		if (mousePoint === null) return;
		appendMouseEventExtensions(event);
		var p = event.relativePoint.scale(SCALE);
	//	console.log("-- move x:"+p.x+", y:"+p.y)
		mousePoint.moveTo(p);
		mouseMoved = true;
		redraw();
	});

	c.addEventListener("mouseup", function(event) {
		if (mousePoint === null) return;
		appendMouseEventExtensions(event);
		var p = event.relativePoint.scale(SCALE);
	//	console.log("-> up   x:"+p.x+", y:"+p.y)
		if (mouseMoved) {
			path = userPath.clone();
		} else {
			if (userPath.path.length > 3) {
				userPath.remove(mousePointIndex);
			}
			path = userPath.clone();
		}
		mousePoint = null;
		mousePointIndex = null;
		mouseMoved = false;
		redraw();
	});

	c.addEventListener("mouseout", function(event) {
		if (mousePoint === null) return;
		appendMouseEventExtensions(event);
		mousePoint = null;
		mousePointIndex = null;
		mouseMoved = false;
		var p = event.relativePoint.scale(SCALE);
	//	console.log("-> out  x:"+p.x+", y:"+p.y)
		userPath = path.clone();
		redraw();
	});
})();

/* add algoritm selection */
(function() {
	var algContainer = document.getElementById("alg_cont");
	for (a = 0; a < algorithms.length; ++a) {
		var alg = algorithms[a];
		var container = document.createElement("div");
		var label = document.createElement("label");
		var input = document.createElement("input");
		input.type = "checkbox";
		input.alg = alg;
		input.addEventListener("input", function(event) {
			event.target.alg.show = event.target.checked;
			redraw();
		});
		input.name = "alg"+a;
		input.id = "alg"+a;
		input.checked = alg.show;
		label.appendChild(input);
		var desc = document.createTextNode(alg.desc);
		label.appendChild(desc);
		container.appendChild(label);
		
		
		algContainer.appendChild(container);
	}
})();

redraw();

</script>
</body>
</html>
